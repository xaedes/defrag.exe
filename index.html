<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DEFRAG.EXE ‚Äî Hard Disk Defragmenter</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap');

  :root {
    --green: #00ff41;
    --green-dim: #00aa2a;
    --green-dark: #003310;
    --amber: #ffb000;
    --red: #ff3333;
    --blue: #0088ff;
    --cyan: #00ffff;
    --magenta: #ff00ff;
    --white: #ccffcc;
    --bg: #050f05;
    --bg2: #0a180a;
    --panel: #071007;
    --border: #005500;
    --gold: #ffd700;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px;
    min-height: 100vh;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg, transparent, transparent 2px,
      rgba(0,0,0,0.15) 2px, rgba(0,0,0,0.15) 4px
    );
    pointer-events: none;
    z-index: 1000;
  }

  body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,255,65,0.02);
    pointer-events: none;
    z-index: 999;
    animation: flicker 0.15s infinite;
  }

  @keyframes flicker { 0%,100% { opacity: 1; } 50% { opacity: 0.97; } }

  .screen { max-width: 1400px; margin: 0 auto; padding: 10px; }

  .header {
    text-align: center;
    padding: 8px 0 4px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 10px;
  }

  .header h1 {
    font-family: 'VT323', monospace;
    font-size: 32px;
    color: var(--green);
    text-shadow: 0 0 10px var(--green), 0 0 20px var(--green-dim);
    letter-spacing: 4px;
  }

  .header .subtitle { color: var(--green-dim); font-size: 11px; letter-spacing: 2px; }

  .stats-bar {
    display: flex;
    gap: 16px;
    padding: 5px 0;
    border-bottom: 1px solid var(--border);
    margin-bottom: 8px;
    flex-wrap: wrap;
    align-items: center;
  }

  .stat { display: flex; gap: 6px; align-items: center; }
  .stat-label { color: var(--green-dim); }
  .stat-value { color: var(--amber); font-weight: bold; }
  .stat-value.good { color: var(--green); }
  .stat-value.bad { color: var(--red); }
  .stat-value.gold { color: var(--gold); text-shadow: 0 0 8px var(--gold); }

  .money-display {
    font-family: 'VT323', monospace;
    font-size: 22px;
    color: var(--gold);
    text-shadow: 0 0 10px rgba(255,215,0,0.5);
    letter-spacing: 1px;
    border: 1px solid rgba(255,215,0,0.3);
    padding: 2px 10px;
    background: rgba(255,215,0,0.05);
  }

  .money-earn-anim {
    position: fixed;
    pointer-events: none;
    font-family: 'VT323', monospace;
    font-size: 20px;
    color: var(--gold);
    text-shadow: 0 0 8px var(--gold);
    animation: float-up 1.5s ease-out forwards;
    z-index: 2000;
  }
  @keyframes float-up {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-60px); }
  }

  .main-layout {
    display: grid;
    grid-template-columns: 240px 1fr 280px;
    gap: 8px;
    height: calc(100vh - 128px);
  }

  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    padding: 8px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .panel-title {
    font-family: 'VT323', monospace;
    font-size: 18px;
    color: var(--amber);
    text-transform: uppercase;
    border-bottom: 1px solid var(--border);
    padding-bottom: 4px;
    margin-bottom: 4px;
    text-shadow: 0 0 8px var(--amber);
    flex-shrink: 0;
  }

  /* DISK MAP */
  .disk-panel { grid-column: 2; display: flex; flex-direction: column; }
  #disk-map { display: grid; gap: 1px; flex: 1; align-content: start; }

  .block {
    width: 100%;
    aspect-ratio: 1;
    border-radius: 1px;
    cursor: default;
    transition: opacity 0.1s;
    position: relative;
  }

  #block-tooltip {
    position: fixed;
    background: #000;
    border: 1px solid var(--green);
    color: var(--green);
    padding: 2px 6px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 500;
    pointer-events: none;
    display: none;
    font-family: 'Share Tech Mono', monospace;
  }

  .block.free { background: var(--bg2); border: 1px solid #111; }
  .block.used { border: none; }
  @keyframes blink-read { 0%,100% { filter: none; } 50% { filter: brightness(3) saturate(0); } }
  @keyframes blink-write { 0%,100% { filter: none; } 50% { filter: brightness(4); } }
  .block.defrag-read { animation: blink-read 0.2s; }
  .block.defrag-write { animation: blink-write 0.2s; }

  /* Read/write head block highlights */
  .block.head-read {
    outline: 2px solid var(--cyan) !important;
    box-shadow: 0 0 6px var(--cyan), inset 0 0 4px rgba(0,255,255,0.3);
    position: relative;
    z-index: 2;
  }
  .block.head-write {
    outline: 2px solid var(--amber) !important;
    box-shadow: 0 0 6px var(--amber), inset 0 0 4px rgba(255,176,0,0.3);
    position: relative;
    z-index: 2;
  }

  .btn {
    background: transparent;
    border: 1px solid var(--green-dim);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    padding: 4px 8px;
    cursor: pointer;
    text-align: left;
    width: 100%;
    transition: all 0.1s;
  }
  .btn:hover { background: var(--green-dark); border-color: var(--green); color: var(--white); }
  .btn:disabled { opacity: 0.3; cursor: not-allowed; }
  .btn.primary { border-color: var(--amber); color: var(--amber); }
  .btn.primary:hover { background: #1a0e00; }
  .btn.danger { border-color: var(--red); color: var(--red); }
  .btn.danger:hover { background: #1a0000; }
  .btn.run { border-color: var(--cyan); color: var(--cyan); font-family: 'VT323', monospace; font-size: 18px; letter-spacing: 1px; }
  .btn.run:hover { background: #001a1a; }
  .btn.gold-btn { border-color: var(--gold); color: var(--gold); }
  .btn.gold-btn:hover { background: rgba(255,215,0,0.08); }
  .btn.stop-btn { border-color: var(--red); color: var(--red); font-family: 'VT323', monospace; font-size: 18px; }
  .btn.stop-btn:hover { background: #1a0000; }

  input[type="text"], input[type="number"], select {
    background: #050f05;
    border: 1px solid var(--border);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    padding: 3px 6px;
    width: 100%;
    outline: none;
  }
  input:focus, select:focus { border-color: var(--green); }
  select option { background: #050f05; }

  .input-row {
    display: flex;
    gap: 4px;
    align-items: center;
  }
  .input-row label { color: var(--green-dim); white-space: nowrap; font-size: 11px; min-width: 55px; }

  .file-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 2px 4px;
    cursor: pointer;
    border: 1px solid transparent;
    transition: all 0.1s;
  }
  .file-item:hover { border-color: var(--border); background: var(--green-dark); }
  .file-item.selected { border-color: var(--green-dim); background: var(--green-dark); }
  .file-dot { width: 8px; height: 8px; border-radius: 1px; flex-shrink: 0; }
  .file-name { flex: 1; font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .file-size { color: var(--green-dim); font-size: 10px; min-width: 40px; text-align: right; }
  .file-frag { font-size: 10px; }
  .file-frag.bad { color: var(--red); }
  .file-frag.ok { color: var(--green-dim); }

  #log { flex: 1; overflow-y: auto; font-size: 11px; line-height: 1.6; }
  .log-line { color: var(--green-dim); }
  .log-line.action { color: var(--green); }
  .log-line.warn { color: var(--amber); }
  .log-line.err { color: var(--red); }
  .log-line.defrag { color: var(--cyan); }
  .log-line.money { color: var(--gold); }
  .log-line.crash { color: var(--red); font-weight: bold; }

  .progress-bar { height: 14px; background: var(--bg2); border: 1px solid var(--border); overflow: hidden; }
  .progress-fill { height: 100%; background: var(--cyan); transition: width 0.1s linear; box-shadow: 0 0 6px var(--cyan); }

  .separator { border: none; border-top: 1px solid var(--border); margin: 2px 0; }

  .legend { display: flex; flex-wrap: wrap; gap: 6px; font-size: 10px; }
  .legend-item { display: flex; gap: 4px; align-items: center; }
  .legend-dot { width: 8px; height: 8px; border-radius: 1px; }

  .defrag-status {
    font-family: 'VT323', monospace;
    font-size: 20px;
    color: var(--cyan);
    text-align: center;
    text-shadow: 0 0 10px var(--cyan);
    min-height: 26px;
  }

  .fragmentation-meter { height: 8px; background: var(--bg2); border: 1px solid var(--border); overflow: hidden; }
  .frag-fill { height: 100%; transition: width 0.5s; background: linear-gradient(to right, var(--green), var(--amber), var(--red)); }

  /* SOFTWARE CARDS */
  .software-card {
    border: 1px solid var(--border);
    padding: 6px;
    background: rgba(0,40,0,0.3);
    transition: border-color 0.1s;
  }
  .software-card.running { border-color: var(--cyan); background: rgba(0,40,40,0.3); }
  .software-card.crashed { border-color: var(--red); background: rgba(40,0,0,0.2); }
  .software-card.locked { opacity: 0.5; border-style: dashed; }

  .sw-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
  .sw-name { font-family: 'VT323', monospace; font-size: 16px; color: var(--green); }
  .sw-name.running-name { color: var(--cyan); text-shadow: 0 0 6px var(--cyan); }
  .sw-name.crashed-name { color: var(--red); }
  .sw-badge {
    font-size: 9px;
    padding: 1px 4px;
    border: 1px solid currentColor;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .sw-badge.server { color: var(--magenta); }
  .sw-badge.idle { color: var(--green-dim); }

  .sw-info { font-size: 10px; color: var(--green-dim); line-height: 1.5; margin-bottom: 4px; }
  .sw-info span { color: var(--amber); }

  .sw-progress { height: 4px; background: var(--bg2); border: 1px solid var(--border); margin: 3px 0; overflow: hidden; }
  .sw-progress-fill { height: 100%; background: var(--cyan); transition: width 0.15s; }

  .sw-btn-row { display: flex; gap: 4px; }
  .sw-btn { flex: 1; font-size: 11px; padding: 2px 6px; font-family: 'VT323', monospace; font-size: 15px; }

  /* SHOP */
  .shop-item {
    border: 1px solid var(--border);
    padding: 5px;
    background: rgba(0,20,0,0.3);
  }
  .shop-item:hover { border-color: var(--green-dim); }
  .shop-name { font-family: 'VT323', monospace; font-size: 15px; color: var(--amber); }
  .shop-desc { font-size: 10px; color: var(--green-dim); margin: 2px 0; }
  .shop-price { color: var(--gold); font-size: 11px; }
  .shop-req { font-size: 10px; color: var(--red); margin-bottom: 3px; }

  /* RAM display */
  .ram-bar { height: 10px; background: var(--bg2); border: 1px solid var(--border); overflow: hidden; margin-top: 3px; }
  .ram-fill { height: 100%; background: var(--amber); transition: width 0.3s; box-shadow: 0 0 4px var(--amber); }

  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--green-dim); }
</style>
</head>
<body>
<div id="block-tooltip"></div>
<div class="screen">
  <div class="header">
    <h1>‚¨õ DEFRAG.EXE v4.2</h1>
    <div class="subtitle">MIRACULOUS DISK DEFRAGMENTER &amp; SYSTEMS MANAGEMENT SUITE</div>
  </div>

  <div class="stats-bar">
    <div class="stat"><span class="money-display" id="money-display">$ 0.00</span></div>
    <div class="stat"><span class="stat-label">DRIVE:</span><span class="stat-value" id="stat-drive">C:\</span></div>
    <div class="stat"><span class="stat-label">CAPACITY:</span><span class="stat-value" id="stat-capacity">512 BLK</span></div>
    <div class="stat"><span class="stat-label">USED:</span><span id="stat-used" class="stat-value">0 BLK</span></div>
    <div class="stat"><span class="stat-label">FREE:</span><span id="stat-free" class="stat-value good">512 BLK</span></div>
    <div class="stat"><span class="stat-label">FILES:</span><span id="stat-files" class="stat-value">0</span></div>
    <div class="stat"><span class="stat-label">FRAG:</span><span id="stat-frag" class="stat-value good">0%</span></div>
    <div class="stat"><span class="stat-label">RAM:</span><span id="stat-ram" class="stat-value">256 KB</span></div>
    <div class="stat"><span class="stat-label">R-HEADS:</span><span id="stat-rheads" class="stat-value good">1</span></div>
    <div class="stat"><span class="stat-label">W-HEADS:</span><span id="stat-wheads" class="stat-value good">1</span></div>
    <div class="stat" style="flex:1"><div class="fragmentation-meter"><div class="frag-fill" id="frag-meter" style="width:0%"></div></div></div>
  </div>

  <div class="main-layout">
    <!-- LEFT: SOFTWARE PANEL -->
    <div class="panel" id="left-panel">
      <div class="panel-title">üíæ Software</div>
      <div id="software-list" style="display:flex;flex-direction:column;gap:6px;flex:1;overflow-y:auto;"></div>
      <hr class="separator">
      <div class="panel-title" style="font-size:14px">üõí Shop</div>
      <div id="shop-list" style="display:flex;flex-direction:column;gap:5px;overflow-y:auto;max-height:260px;"></div>
    </div>

    <!-- CENTER: DISK MAP -->
    <div class="panel disk-panel">
      <div class="panel-title">üíæ DISK BLOCK MAP ‚Äî C:\</div>

      <!-- DEFRAG CONTROLS ‚Äî top -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
        <div>
          <div style="color:var(--green-dim);font-size:11px;margin-bottom:3px">DEFRAG MODE:</div>
          <select id="defrag-mode">
            <option value="simple">Simple Defrag</option>
            <option value="consolidate">Consolidate Free Space</option>
            <option value="byname">Sort by Filename</option>
            <option value="bydate">Sort by Modification Date</option>
            <option value="bysize">Sort by File Size</option>
          </select>
        </div>
        <div>
          <div style="color:var(--green-dim);font-size:11px;margin-bottom:3px">SPEED:</div>
          <select id="defrag-speed">
            <option value="30">Turbo (30ms)</option>
            <option value="60" selected>Fast (60ms)</option>
            <option value="120">Normal (120ms)</option>
            <option value="250">Slow (250ms)</option>
          </select>
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
        <button class="btn run" id="btn-defrag" onclick="startDefrag()">‚ñ∂ RUN DEFRAG</button>
        <button class="btn danger" id="btn-stop" onclick="stopDefrag()" disabled>‚ñ† STOP</button>
      </div>
      <div class="defrag-status" id="defrag-status">READY</div>
      <div class="progress-bar" style="margin: 2px 0"><div class="progress-fill" id="defrag-progress" style="width:0%"></div></div>

      <hr class="separator">

      <!-- BLOCK MAP -->
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#111;border:1px solid #222"></div> Free</div>
        <div class="legend-item"><div class="legend-dot" style="background:#0066ff"></div> System</div>
        <div class="legend-item"><div class="legend-dot" style="border:2px solid var(--cyan);background:transparent"></div> R-Head</div>
        <div class="legend-item"><div class="legend-dot" style="border:2px solid var(--amber);background:transparent"></div> W-Head</div>
        <div id="legend-files" class="legend" style="flex:1"></div>
      </div>
      <div id="disk-map" style="margin-top:6px;flex:1;overflow-y:auto;"></div>
    </div>

    <!-- RIGHT: FILE LIST + LOG + HW -->
    <div class="panel">
      <!-- Hardware info -->
      <div class="panel-title" style="font-size:14px">‚öô Hardware</div>
      <div style="font-size:11px;color:var(--green-dim)">
        RAM: <span id="hw-ram" style="color:var(--amber)">256 KB</span>
        &nbsp;|&nbsp; RAM Used: <span id="hw-ram-used" style="color:var(--amber)">0 KB</span>
      </div>
      <div class="ram-bar"><div class="ram-fill" id="ram-fill" style="width:0%"></div></div>
      <div style="font-size:10px;color:var(--green-dim);margin-top:2px">
        HDD: <span id="hw-hdd" style="color:var(--amber)">512 BLK</span>
        &nbsp;|&nbsp; R-Heads: <span id="hw-rheads" style="color:var(--cyan)">1</span>
        &nbsp;|&nbsp; W-Heads: <span id="hw-wheads" style="color:var(--amber)">1</span>
      </div>

      <hr class="separator">
      <div class="panel-title">üìÇ Files</div>
      <div id="file-list" style="flex:1;overflow-y:auto;max-height:220px;border:1px solid var(--border);padding:2px;min-height:60px;"></div>

      <hr class="separator">
      <div class="panel-title" style="font-size:14px">üìü Activity Log</div>
      <div id="log" style="flex:1;border:1px solid var(--border);padding:4px;min-height:80px;max-height:280px;overflow-y:auto;"></div>

      <!-- Manual FS ops ‚Äî always expanded -->
      <hr class="separator">
      <div class="panel-title" style="font-size:14px">üìÅ Filesystem Ops</div>
      <div class="input-row">
        <label>Filename:</label>
        <input type="text" id="in-filename" value="FILE001.DAT" maxlength="12">
      </div>
      <div class="input-row">
        <label>Size (blk):</label>
        <input type="number" id="in-size" value="8" min="1" max="50">
      </div>
      <button class="btn" id="btn-chkdsk" onclick="toggleChkdsk()">‚ñ∂ CHKDSK</button>
      <button class="btn" onclick="opCreate()">‚ñ∂ CREATE FILE</button>
      <button class="btn" onclick="opAppend()">‚ñ∂ APPEND TO FILE</button>
      <button class="btn" onclick="opDelete()">‚ñ∂ DELETE FILE</button>
      <button class="btn" onclick="opRename()">‚ñ∂ RENAME FILE</button>
      <button class="btn" onclick="opModify()">‚ñ∂ MODIFY (touch)</button>

      <!-- Bulk ops ‚Äî collapsed by default -->
      <details>
        <summary style="color:var(--green-dim);font-size:11px;cursor:pointer;user-select:none;margin-top:4px;">‚ñ∂ Bulk Operations</summary>
        <div style="display:flex;flex-direction:column;gap:5px;margin-top:5px;">
          <div class="input-row">
            <label>Count:</label>
            <input type="number" id="in-bulk-count" value="10" min="1" max="50">
          </div>
          <button class="btn primary" onclick="bulkCreate()">‚¨õ BULK CREATE</button>
          <button class="btn primary" onclick="bulkDeleteRandom()">‚¨õ BULK DELETE RANDOM</button>
          <button class="btn primary" onclick="bulkCreateDelete()">‚¨õ CREATE+DELETE CYCLE</button>
          <button class="btn primary" onclick="bulkAppendAll()">‚¨õ APPEND ALL FILES</button>
        </div>
      </details>
    </div>
  </div>
</div>

<script>
// ==========================================
// GAME STATE
// ==========================================
let DISK_SIZE = 512;
let RAM_SIZE = 256; // KB
const COLS = 32;

let disk = [];
let files = {};
let nextFileId = 1;
let selectedFileId = null;
let defragRunning = false;
let chkdskRunning = false;
let chkdskStopRequested = false;
let playerMoney = 0;

// swInstances is declared near RAM TRACKING section

const SYSTEM_BLOCKS = 4;

// ==========================================
// DISK HEAD SYSTEM ‚Äî Multi-head with locking
// ==========================================
const HEAD_SNAP = 0.08;

function getHeadSpeed() {
  const sel = document.getElementById('defrag-speed');
  const ms = sel ? parseInt(sel.value) : 60;
  return Math.round(1200 / ms);
}

function blockToXY(blockIdx) {
  return { x: blockIdx % COLS, y: Math.floor(blockIdx / COLS) };
}

function xyToNearestBlock(x, y) {
  const col = Math.max(0, Math.min(COLS - 1, Math.round(x)));
  const row = Math.max(0, Math.min(Math.floor(DISK_SIZE / COLS) - 1, Math.round(y)));
  return row * COLS + col;
}

// Head pools ‚Äî start with one of each, expandable via shop
// Each head: { id, type:'read'|'write', x, y, targetBlock, cssClass, visBlock, inUse: bool }
let readHeads  = [];
let writeHeads = [];

function makeHead(type, idx) {
  return {
    id: `${type}-${idx}`,
    type,
    x: idx * 2,
    y: 0,
    targetBlock: idx * 2,
    cssClass: type === 'read' ? 'head-read' : 'head-write',
    visBlock: idx * 2,
    inUse: false,
  };
}

function initHeads() {
  readHeads  = [makeHead('read', 0)];
  writeHeads = [makeHead('write', 0)];
}

function addReadHead() {
  readHeads.push(makeHead('read', readHeads.length));
  log(`Read head #${readHeads.length} installed`, 'action');
}

function addWriteHead() {
  writeHeads.push(makeHead('write', writeHeads.length));
  log(`Write head #${writeHeads.length} installed`, 'action');
}

// Distance from head's current position to a given block index
function headDistTo(head, targetBlockIdx) {
  const t = blockToXY(targetBlockIdx);
  const dx = head.x - t.x;
  const dy = head.y - t.y;
  return Math.sqrt(dx*dx + dy*dy);
}

// Acquire the closest free head from a pool to the given target block (blocks until one is available)
async function acquireHead(pool, targetBlockIdx) {
  while (true) {
    let best = null, bestDist = Infinity;
    for (const h of pool) {
      if (!h.inUse) {
        const d = headDistTo(h, targetBlockIdx);
        if ((targetBlockIdx === undefined) || (d < bestDist)) { bestDist = d; best = h; }
      }
    }
    if (best) {
      best.inUse = true;
      return best;
    }
    // None free ‚Äî wait a tick and retry
    await sleep(20);
  }
}

function releaseHead(head) {
  head.inUse = false;
}

// Move a specific head to a block; resolves when arrived
function moveHeadTo(head, blockIdx) {
  head.targetBlock = blockIdx;
  const target = blockToXY(blockIdx);

  return new Promise(resolve => {
    let lastTime = null;

    function step(ts) {
      if (lastTime === null) lastTime = ts;
      const dt = Math.min((ts - lastTime) / 1000, 0.05);
      lastTime = ts;

      const dx = target.x - head.x;
      const dy = target.y - head.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (isNaN(dist)) {
        throw new Error('');
      }
      if (dist <= HEAD_SNAP) {
        head.x = target.x;
        head.y = target.y;
        const newVis = xyToNearestBlock(head.x, head.y);
        updateHeadVisual(head, newVis);
        resolve();
        return;
      }

      const move = getHeadSpeed() * dt;
      const ratio = Math.min(1, move / dist);
      head.x += dx * ratio;
      head.y += dy * ratio;

      const newVis = xyToNearestBlock(head.x, head.y);
      updateHeadVisual(head, newVis);

      requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
  });
}

function updateHeadVisual(head, newVisBlock) {
  if (newVisBlock !== head.visBlock) {
    const oldEl = document.querySelector(`[data-block="${head.visBlock}"]`);
    if (oldEl) oldEl.classList.remove(head.cssClass);
    head.visBlock = newVisBlock;
  }
  const el = document.querySelector(`[data-block="${head.visBlock}"]`);
  if (el) el.classList.add(head.cssClass);
}

// High-level helpers: acquire closest free head, move it, return it locked.
// Caller must releaseHead() when done with the operation.
async function acquireAndMoveReadHead(blockIdx) {
  const head = await acquireHead(readHeads, blockIdx);
  await moveHeadTo(head, blockIdx);
  return head;
}

async function acquireAndMoveWriteHead(blockIdx) {
  const head = await acquireHead(writeHeads, blockIdx);
  await moveHeadTo(head, blockIdx);
  return head;
}

// Compatibility wrappers used by defrag (acquire + move + release)
async function moveReadHead(blockIdx) {
  const head = await acquireAndMoveReadHead(blockIdx);
  releaseHead(head);
}

async function moveWriteHead(blockIdx) {
  const head = await acquireAndMoveWriteHead(blockIdx);
  releaseHead(head);
}

// ==========================================
// SHOP CATALOG
// ==========================================
const SHOP_UPGRADES = [
  {
    id: 'rhead2',
    name: 'Read Head #2',
    desc: 'Second read head ‚Äî parallel software reads.',
    price: 80,
    ramReq: 0,
    type: 'rhead',
    bought: false,
  },
  {
    id: 'rhead3',
    name: 'Read Head #3',
    desc: 'Third read head ‚Äî maximum read parallelism.',
    price: 250,
    ramReq: 0,
    type: 'rhead',
    requires: 'rhead2',
    bought: false,
  },
  {
    id: 'whead2',
    name: 'Write Head #2',
    desc: 'Second write head ‚Äî parallel software writes.',
    price: 100,
    ramReq: 0,
    type: 'whead',
    bought: false,
  },
  {
    id: 'whead3',
    name: 'Write Head #3',
    desc: 'Third write head ‚Äî maximum write throughput.',
    price: 320,
    ramReq: 0,
    type: 'whead',
    requires: 'whead2',
    bought: false,
  },
  {
    id: 'hdd512',
    name: 'HDD Upgrade: 1024 BLK',
    desc: 'Double your disk capacity to 1024 blocks.',
    price: 50,
    ramReq: 0,
    type: 'hdd',
    value: 1024,
    bought: false,
  },
  {
    id: 'hdd2048',
    name: 'HDD Upgrade: 2048 BLK',
    desc: 'Expand to 2048 blocks of storage.',
    price: 300,
    ramReq: 0,
    type: 'hdd',
    value: 2048,
    bought: false,
  },
  {
    id: 'ram512',
    name: 'RAM Upgrade: 512 KB',
    desc: 'More memory ‚Äî run heavier software.',
    price: 30,
    ramReq: 0,
    type: 'ram',
    value: 512,
    bought: false,
  },
  {
    id: 'ram1024',
    name: 'RAM Upgrade: 1024 KB',
    desc: 'Beefy RAM for server-class programs.',
    price: 150,
    ramReq: 512,
    type: 'ram',
    value: 1024,
    bought: false,
  },
  {
    id: 'ram2048',
    name: 'RAM Upgrade: 2048 KB',
    desc: 'Enterprise-grade memory headroom.',
    price: 800,
    ramReq: 1024,
    type: 'ram',
    value: 2048,
    bought: false,
  },
];

// ==========================================
// SOFTWARE CATALOG
// ==========================================
// Operations: { op: 'create'|'append'|'delete'|'read'|'earn', file?, size?, amount? }
// 'file' can be a key string ‚Üí persistent named file; or null ‚Üí temp file (tracked per-run)
// read: offset (default 0, negative = from end), size (default all, negative = relative to end)
const SOFTWARE_CATALOG = [
  {
    id: 'sw_ledger',
    name: 'LEDGER.EXE',
    desc: 'A tiny accounting script. Reads a ledger file and earns a small fee.',
    badgeType: 'idle',
    price: 0, // starter ‚Äî free / auto-installed
    ramReq: 64,
    isServer: false,
    persistentFiles: [
      { key: 'ledger_dat', name: 'LEDGER.DAT', size: 2 }
    ],
    ops: [
      { op: 'read', file: 'ledger_dat', offset: 0, size: -1 }, // read whole file
      { op: 'earn', amount: 10.05 },
    ],
  },
  {
    id: 'sw_sorter',
    name: 'SORTR.EXE',
    desc: 'Sorts data batches. Creates temp files and earns on completion.',
    badgeType: 'idle',
    price: 15,
    ramReq: 128,
    isServer: false,
    persistentFiles: [
      { key: 'sort_cfg', name: 'SORTR.CFG', size: 1 },
    ],
    ops: [
      { op: 'create', file: null, name: 'SORT_TMP.DAT', size: 5 },
      { op: 'read', file: 'sort_cfg', offset: 0, size: -1 },  // read whole config
      { op: 'append', file: null, size: 3 },
      { op: 'earn', amount: 0.30 },
      { op: 'delete', file: null },
    ],
  },
  {
    id: 'sw_archiver',
    name: 'ARCHIVR.EXE',
    desc: 'Compresses and archives files. Moderate earnings.',
    badgeType: 'idle',
    price: 60,
    ramReq: 256,
    isServer: false,
    persistentFiles: [
      { key: 'arch_idx', name: 'ARCH.IDX', size: 3 },
      { key: 'arch_db', name: 'ARCH.DB', size: 8 },
    ],
    ops: [
      { op: 'read', file: 'arch_idx', offset: 0, size: -1 },  // scan full index
      { op: 'create', file: null, name: 'PACK.TMP', size: 12 },
      { op: 'append', file: 'arch_db', size: 4 },
      { op: 'read', file: 'arch_db', offset: -2, size: -1 },  // verify last 2 written blocks
      { op: 'earn', amount: 1.20 },
      { op: 'delete', file: null },
    ],
  },
  {
    id: 'sw_cruncher',
    name: 'CRUNCHR.EXE',
    desc: 'Number crunching daemon. Runs continuously as a server.',
    badgeType: 'server',
    price: 200,
    ramReq: 512,
    isServer: true,
    persistentFiles: [
      { key: 'crunch_cfg', name: 'CRUNCH.CFG', size: 2 },
      { key: 'crunch_log', name: 'CRUNCH.LOG', size: 6 },
    ],
    ops: [
      { op: 'read', file: 'crunch_cfg', offset: 0, size: -1 },   // read full config
      { op: 'create', file: null, name: 'CHUNK.TMP', size: 8 },
      { op: 'read', file: 'crunch_log', offset: -1, size: -1 },  // check tail of log
      { op: 'append', file: 'crunch_log', size: 2 },
      { op: 'earn', amount: 3.50 },
      { op: 'delete', file: null },
      // Truncate crunch_log when it grows beyond 128 blocks
      { op: 'push_size', file: 'crunch_log' },
      { op: 'push', value: 128 },
      { op: 'compare', cmp: 'lt' },   // stack: [crunch_log.size < 128]
      { op: 'if' },                    // if true (size < 128): skip next op (exit), so we do truncate
      { op: 'exit' },                  // size is fine, bail out early
      { op: 'truncate', file: 'crunch_log', offset: 0, size: -1 },  // free all blocks ‚Üí truncate to empty; pushes freed count
      { op: 'pop' },  // discard freed count, not needed here
    ],
  },
  {
    id: 'sw_datamill',
    name: 'DATAMILL.EXE',
    desc: 'Continuous data pipeline. Heavy on disk. High reward server.',
    badgeType: 'server',
    price: 800,
    ramReq: 1024,
    isServer: true,
    persistentFiles: [
      { key: 'mill_cfg', name: 'MILL.CFG', size: 2 },
      { key: 'mill_idx', name: 'MILL.IDX', size: 10 },
      { key: 'mill_out', name: 'MILL.OUT', size: 20 },
    ],
    ops: [
      { op: 'read', file: 'mill_cfg', offset: 0, size: -1 },       // full config
      { op: 'read', file: 'mill_idx', offset: -3, size: -1 },      // scan last 3 index entries
      { op: 'create', file: null, name: 'PIPE_A.TMP', size: 15 },
      { op: 'create', file: null, name: 'PIPE_B.TMP', size: 10 },
      { op: 'append', file: 'mill_out', size: 5 },
      { op: 'append', file: 'mill_idx', size: 3 },
      { op: 'earn', amount: 18.00 },
      { op: 'delete', file: null, which: 'PIPE_A.TMP' },
      { op: 'delete', file: null, which: 'PIPE_B.TMP' },
    ],
  },
  {
    id: 'sw_gridnode',
    name: 'GRIDNODE.SRV',
    desc: 'A compute grid node. Massively fragments disk. Enormous revenue.',
    badgeType: 'server',
    price: 3000,
    ramReq: 2048,
    isServer: true,
    persistentFiles: [
      { key: 'gn_cfg', name: 'GRID.CFG', size: 3 },
      { key: 'gn_state', name: 'GRID.STA', size: 15 },
      { key: 'gn_db', name: 'GRID.DB', size: 40 },
    ],
    ops: [
      { op: 'read', file: 'gn_cfg', offset: 0, size: -1 },        // full config
      { op: 'read', file: 'gn_state', offset: 0, size: 4 },       // read first 4 state blocks
      { op: 'create', file: null, name: 'NODE_A.TMP', size: 20 },
      { op: 'create', file: null, name: 'NODE_B.TMP', size: 18 },
      { op: 'create', file: null, name: 'NODE_C.TMP', size: 14 },
      { op: 'append', file: 'gn_db', size: 8 },
      { op: 'append', file: 'gn_state', size: 4 },
      { op: 'read', file: 'gn_db', offset: -4, size: -1 },        // verify last 4 db blocks
      { op: 'earn', amount: 90.00 },
      { op: 'delete', file: null, which: 'NODE_A.TMP' },
      { op: 'delete', file: null, which: 'NODE_B.TMP' },
      { op: 'delete', file: null, which: 'NODE_C.TMP' },
    ],
  },
  {
    id: 'sw_scavenger',
    name: 'SCAVNGR.EXE',
    desc: 'Scavenges disk space by fragmenting tmps into a rolling buffer, then reclaims random chunks. Earns per block reclaimed.',
    badgeType: 'server',
    price: 500,
    ramReq: 512,
    isServer: true,
    persistentFiles: [
      { key: 'scav_buf', name: 'SCAV.BUF', size: 10 },
      { key: 'scav_idx', name: 'SCAV.IDX', size: 4 },
    ],
    ops: [
      // Append a fixed chunk to the rolling buffer each cycle
      { op: 'append', file: 'scav_buf', size: 6 },
      // Read the whole buffer to "process" it
      { op: 'read', file: 'scav_buf', offset: 0, size: -1 },
      // Check if buffer has grown past threshold (60 blocks)
      { op: 'push_size', file: 'scav_buf' },
      { op: 'push', value: 60 },
      { op: 'compare', cmp: 'lt' },  // size < 60?
      { op: 'if' },                  // true (small): skip exit ‚Üí jump to truncate section
      { op: 'exit' },                // buffer is fine, bail early
      // Create a handful of tmps to fragment the disk
      { op: 'create', file: null, name: 'SCAV_A.TMP', size: 7 },
      { op: 'create', file: null, name: 'SCAV_B.TMP', size: 5 },
      { op: 'create', file: null, name: 'SCAV_C.TMP', size: 9 },
      // truncate pops offset first (top), then size ‚Äî so push size first, then offset
      { op: 'push_size', file: 'scav_buf' },  // [total]
      { op: 'push', value: 4 },
      { op: 'calc', op2: 'div' },             // [total/4]  ‚Üê this becomes the size to reclaim
      { op: 'push_random', min: 0.5, max: 1.5 },
      { op: 'calc', op2: 'mul' },             // [rand_size ‚âà total/8..total/3]  ‚Üê SIZE (pushed first = under)
      { op: 'push_size', file: 'scav_buf' },  // [rand_size, total]
      { op: 'push', value: 2 },
      { op: 'calc', op2: 'div' },             // [rand_size, total/2]
      { op: 'push_random', min: 0, max: 1 },  // [rand_size, total/2, rand 0..1]
      { op: 'calc', op2: 'mul' },             // [rand_size, offset ‚âà 0..total/2]  ‚Üê OFFSET (pushed last = top)
      // truncate pops offset (top), then size (under); pushes freed_count
      { op: 'truncate', file: 'scav_buf' },
      // Earn $1.50 per reclaimed block
      { op: 'push', value: 1.50 },
      { op: 'calc', op2: 'mul' },
      { op: 'earn' },
      // Update index to log the reclaim event
      { op: 'append', file: 'scav_idx', size: 1 },
      // Clean up tmps
      { op: 'delete', file: null, which: 'SCAV_A.TMP' },
      { op: 'delete', file: null, which: 'SCAV_B.TMP' },
      { op: 'delete', file: null, which: 'SCAV_C.TMP' },
    ],
  },
];

// installedSoftware: id -> { ...catalog entry, persistentFileIds: { key -> fileId } }
let installedSoftware = {};

// ==========================================
// DISK MODEL
// ==========================================
function initDisk() {
  disk = new Array(DISK_SIZE).fill(null);
  // Reserve system blocks
  for (let i = 0; i < SYSTEM_BLOCKS; i++) disk[i] = 0;
  files[0] = { name: 'SYSTEM', color: '#0044cc', blocks: [...Array(SYSTEM_BLOCKS).keys()], created: 0, modified: 0, size: SYSTEM_BLOCKS, persistent: true };
}

const FILE_COLORS = [
  '#cc4400','#cc8800','#aacc00','#00cc44','#00ccaa','#0088cc',
  '#4400cc','#aa00cc','#cc0066','#cc2200','#66cc00','#00cc88',
  '#0066cc','#6600cc','#cc0088','#ff6600','#ffaa00','#88ff00',
  '#dd4499','#44ddcc','#ccdd44','#ff4444',
];
let colorIdx = 0;
function nextColor() { return FILE_COLORS[colorIdx++ % FILE_COLORS.length]; }

function findFreeBlocks(count) {
  let free = [];
  for (let i = SYSTEM_BLOCKS; i < DISK_SIZE && free.length < count; i++) {
    if (disk[i] === null) free.push(i);
  }
  return free.length >= count ? free : null;
}

function allocateFile(name, size, opts = {}) {
  const blocks = findFreeBlocks(size);
  if (!blocks) { log(`DISK FULL ‚Äî cannot create ${name}`, 'err'); return null; }
  const id = nextFileId++;
  const color = opts.color || nextColor();
  blocks.forEach(b => disk[b] = id);
  files[id] = {
    name, color,
    blocks: [...blocks],
    created: Date.now(),
    modified: Date.now(),
    size,
    persistent: opts.persistent || false,
    swId: opts.swId || null,
  };
  if (!opts.silent) log(`Created ${name} [${size} blk]`, 'action');
  return id;
}

function deleteFile(id) {
  if (!files[id] || id === 0) return false;
  files[id].blocks.forEach(b => disk[b] = null);
  delete files[id];
  // Always clear selection if this file was selected or selected file no longer exists
  if (selectedFileId === id || !files[selectedFileId]) selectedFileId = null;
  return true;
}

function appendFile(id, extra) {
  const f = files[id];
  if (!f) return false;
  const newBlocks = findFreeBlocks(extra);
  if (!newBlocks) return false;
  newBlocks.forEach(b => { disk[b] = id; f.blocks.push(b); });
  f.modified = Date.now();
  f.size += extra;
  return true;
}

function countFragments(blocks) {
  if (blocks.length === 0) return 0;
  const sorted = [...blocks].sort((a,b)=>a-b);
  let frags = 1;
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i-1]+1) frags++;
  }
  return frags;
}

function getFragmentation() {
  let totalFragments = 0;
  const used = disk.filter(x => x !== null && x !== 0).length;
  for (const [id, f] of Object.entries(files)) {
    if (parseInt(id) === 0) continue;
    totalFragments += countFragments(f.blocks) - 1;
  }
  if (used === 0) return 0;
  return Math.min(100, Math.round((totalFragments / Math.max(1, used)) * 200));
}

// ==========================================
// RAM TRACKING
// ==========================================
// swInstances: swId -> array of running instance objects
// Each instance: { id, running, crashed, stepIndex, progress, tmpFiles, stopRequested }
let swInstances = {};
let nextInstanceId = 1;

function getRamUsed() {
  let used = 0;
  for (const [swId, instances] of Object.entries(swInstances)) {
    const sw = installedSoftware[swId];
    if (!sw) continue;
    for (const inst of instances) {
      if (inst.running) used += sw.ramReq;
    }
  }
  return used;
}

function getRamFree() { return RAM_SIZE - getRamUsed(); }

// ==========================================
// SOFTWARE SYSTEM
// ==========================================
function installSoftware(swDef) {
  const sw = { ...swDef, persistentFileIds: {} };
  // Create persistent files
  for (const pf of sw.persistentFiles) {
    const id = allocateFile(pf.name, pf.size, { persistent: true, swId: sw.id, silent: true });
    if (id === null) {
      log(`INSTALL FAILED: disk full for ${sw.name}`, 'err');
      return false;
    }
    sw.persistentFileIds[pf.key] = id;
  }
  installedSoftware[sw.id] = sw;
  swInstances[sw.id] = [];
  log(`Installed ${sw.name}`, 'action');
  render();
  return true;
}

async function runSoftware(swId) {
  const sw = installedSoftware[swId];
  if (!sw) return;

  // Check RAM ‚Äî soft abort (no crash, no reinstall needed)
  if (getRamFree() < sw.ramReq) {
    log(`${sw.name}: NOT ENOUGH RAM (need ${sw.ramReq} KB, free: ${getRamFree()} KB)`, 'warn');
    return;
  }

  // Create a new instance
  const inst = {
    id: nextInstanceId++,
    running: true,
    crashed: false,
    stopRequested: false,
    stepIndex: 0,
    progress: 0,
    tmpFiles: {},
    stack: [],
  };
  swInstances[swId].push(inst);
  log(`${sw.name} #${inst.id}: starting...`, 'action');
  render();

  do {
    let i = 0;
    while (i < sw.ops.length) {
      if (!inst.running || inst.stopRequested) break;
      const op = sw.ops[i];
      inst.stepIndex = i;
      inst.progress = i / sw.ops.length;
      renderSoftwareCard(swId);
      await sleep(80);

      let signal;
      try {
        signal = await executeSoftwareOp(sw, inst, op);
      } catch(e) {
        log(`${sw.name} #${inst.id}: CRASH ‚Äî ${e.message}`, 'crash');
        inst.running = false;
        inst.crashed = true;
        for (const k of Object.keys(inst.tmpFiles)) { if (inst.tmpFiles[k]) deleteFile(inst.tmpFiles[k]); }
        inst.tmpFiles = {};
        setTimeout(() => {
          const arr = swInstances[swId];
          if (arr) { const idx = arr.indexOf(inst); if (idx !== -1) arr.splice(idx, 1); }
          render();
        }, 3000);
        render();
        return;
      }

      render();
      await sleep(50);

      if (signal === 'exit') break;
      if (signal === 'skip') {
        i += 2; // skip next op
      } else {
        i++;
      }
    }

    if (inst.stopRequested) break;

    if (sw.isServer && inst.running) {
      inst.progress = 1;
      renderSoftwareCard(swId);
      await sleep(200);
    }

  } while (sw.isServer && inst.running && !inst.stopRequested);

  // Clean up
  for (const k of Object.keys(inst.tmpFiles)) { if (inst.tmpFiles[k]) deleteFile(inst.tmpFiles[k]); }
  inst.tmpFiles = {};
  inst.running = false;
  inst.progress = 0;
  // Remove from instances array
  const arr = swInstances[swId];
  if (arr) { const idx = arr.indexOf(inst); if (idx !== -1) arr.splice(idx, 1); }
  log(`${sw.name} #${inst.id}: completed`, 'action');
  render();
}

async function executeSoftwareOp(sw, inst, op) {
  switch(op.op) {
    case 'read': {
      let fid;
      if (op.file) {
        fid = sw.persistentFileIds[op.file];
      } else {
        const keys = Object.keys(inst.tmpFiles);
        if (keys.length === 0) throw new Error('no file to read');
        fid = inst.tmpFiles[keys[keys.length - 1]];
      }
      if (!files[fid]) throw new Error(`file ${op.file || '(tmp)'} missing`);
      const f = files[fid];
      const len = f.blocks.length;
      if (len === 0) break;

      const rawOffset = op.offset != null ? op.offset : 0;
      const offset = rawOffset < 0 ? Math.max(0, len + rawOffset) : Math.min(rawOffset, len - 1);

      let count;
      if (op.size == null) {
        count = len - offset;
      } else if (op.size < 0) {
        count = Math.max(0, (len - offset) + op.size + 1);
      } else {
        count = Math.min(op.size, len - offset);
      }

      for (let i = 0; i < count; i++) {
        const blockIdx = f.blocks[offset + i];
        const head = await acquireAndMoveReadHead(blockIdx);
        flashBlock(blockIdx, 'defrag-read');
        releaseHead(head);
      }
      break;
    }
    case 'create': {
      const name = op.name || 'TMP.DAT';
      const size = op.size || 4;
      const fid = allocateFile(name, size, { silent: true, swId: sw.id });
      if (fid === null) throw new Error('disk full');
      const key = op.which || name;
      inst.tmpFiles[key] = fid;
      const f = files[fid];
      for (const blockIdx of f.blocks) {
        const head = await acquireAndMoveWriteHead(blockIdx);
        flashBlock(blockIdx, 'defrag-write');
        releaseHead(head);
      }
      break;
    }
    case 'append': {
      let fid;
      if (op.file) {
        fid = sw.persistentFileIds[op.file];
      } else {
        const keys = Object.keys(inst.tmpFiles);
        if (keys.length === 0) throw new Error('no tmp file to append');
        fid = inst.tmpFiles[keys[keys.length - 1]];
      }
      if (!files[fid]) throw new Error('target file missing');
      const prevLen = files[fid].blocks.length;
      const ok = appendFile(fid, op.size || 2);
      if (!ok) throw new Error('disk full during append');
      const f = files[fid];
      for (let i = prevLen; i < f.blocks.length; i++) {
        const head = await acquireAndMoveWriteHead(f.blocks[i]);
        flashBlock(f.blocks[i], 'defrag-write');
        releaseHead(head);
      }
      break;
    }
    case 'delete': {
      let fid;
      if (op.which) {
        fid = inst.tmpFiles[op.which];
      } else if (op.file) {
        fid = sw.persistentFileIds[op.file];
      } else {
        const keys = Object.keys(inst.tmpFiles);
        if (keys.length === 0) return;
        const k = keys[keys.length - 1];
        fid = inst.tmpFiles[k];
        delete inst.tmpFiles[k];
      }
      if (fid && files[fid]) {
        const keyEntry = Object.entries(inst.tmpFiles).find(([k, v]) => v === fid);
        if (keyEntry) delete inst.tmpFiles[keyEntry[0]];
        const f = files[fid];
        if (f && f.blocks.length > 0) {
          const head = await acquireAndMoveWriteHead(f.blocks[0]);
          flashBlock(f.blocks[0], 'defrag-write');
          releaseHead(head);
        }
        deleteFile(fid);
      }
      break;
    }
    case 'truncate': {
      let fid;
      if (op.file) {
        fid = sw.persistentFileIds[op.file];
      } else {
        const keys = Object.keys(inst.tmpFiles);
        if (keys.length === 0) throw new Error('truncate: no file to truncate');
        fid = inst.tmpFiles[keys[keys.length - 1]];
      }
      if (!files[fid]) throw new Error(`truncate: file ${op.file || '(tmp)'} missing`);
      const tf = files[fid];
      const tlen = tf.blocks.length;

      // offset: op arg takes priority, else pop from stack
      let rawOffset;
      if (op.offset != null) {
        rawOffset = op.offset;
      } else {
        if (inst.stack.length === 0) throw new Error('truncate: stack underflow (offset)');
        rawOffset = inst.stack.pop();
      }

      // size: op arg takes priority, else pop from stack; null/undefined means "rest of file"
      let rawSize;
      if (op.size != null) {
        rawSize = op.size;
      } else if (op.size === null) {
        rawSize = null; // explicitly omitted ‚Äî free to end
      } else {
        if (inst.stack.length === 0) throw new Error('truncate: stack underflow (size)');
        rawSize = inst.stack.pop();
      }

      const offset = Math.round(rawOffset < 0 ? Math.max(0, tlen + rawOffset) : Math.min(rawOffset, tlen));

      let count;
      if (rawSize == null) {
        count = tlen - offset;
      } else if (rawSize < 0) {
        count = Math.max(0, (tlen - offset) + Math.round(rawSize) + 1);
      } else {
        count = Math.min(Math.round(rawSize), tlen - offset);
      }

      // Free the blocks in the range, moving write head to each
      for (let ti = offset; ti < offset + count; ti++) {
        const blockIdx = tf.blocks[ti];
        const head = await acquireAndMoveWriteHead(blockIdx);
        flashBlock(blockIdx, 'defrag-write');
        disk[blockIdx] = null;
        releaseHead(head);
      }
      // Splice them out of the file's block list
      tf.blocks.splice(offset, count);
      tf.size = tf.blocks.length;
      tf.modified = Date.now();
      // Push number of freed blocks so caller can use it (e.g. for earn)
      inst.stack.push(count);
      break;
    }
    case 'push': {
      inst.stack.push(op.value);
      break;
    }
    case 'push_size': {
      let fid;
      if (op.file) {
        fid = sw.persistentFileIds[op.file];
      } else {
        const keys = Object.keys(inst.tmpFiles);
        if (keys.length === 0) throw new Error('push_size: no file to measure');
        fid = inst.tmpFiles[keys[keys.length - 1]];
      }
      if (!files[fid]) throw new Error(`push_size: file ${op.file || '(tmp)'} missing`);
      inst.stack.push(files[fid].blocks.length);
      break;
    }
    case 'push_random': {
      const lo = op.min != null ? op.min : 0;
      const hi = op.max != null ? op.max : 1;
      inst.stack.push(lo + Math.random() * (hi - lo));
      break;
    }
    case 'dup': {
      if (inst.stack.length === 0) throw new Error('dup: stack underflow');
      const top = inst.stack[inst.stack.length - 1];
      inst.stack.push(top);
      break;
    }
    case 'pop': {
      if (inst.stack.length === 0) throw new Error('pop: stack underflow');
      inst.stack.pop();
      break;
    }
    case 'exit': {
      return 'exit';
    }
    case 'crash': {
      throw new Error(op.message || 'forced crash');
    }
    case 'calc': {
      if (inst.stack.length < 2) throw new Error('calc: stack underflow');
      const b = inst.stack.pop();
      const a = inst.stack.pop();
      const op2 = op.op2 || 'add';
      let result;
      if      (op2 === 'add') result = a + b;
      else if (op2 === 'sub') result = a - b;
      else if (op2 === 'mul') result = a * b;
      else if (op2 === 'div') {
        if (b === 0) throw new Error('calc: division by zero');
        result = a / b;
      }
      else throw new Error(`calc: unknown op '${op2}'`);
      inst.stack.push(result);
      break;
    }
    case 'compare': {
      if (inst.stack.length < 2) throw new Error('compare: stack underflow');
      const b = inst.stack.pop();
      const a = inst.stack.pop();
      const cmp = op.cmp || 'eq';
      let result;
      if      (cmp === 'eq')  result = a === b;
      else if (cmp === 'neq') result = a !== b;
      else if (cmp === 'lt')  result = a < b;
      else if (cmp === 'lte') result = a <= b;
      else if (cmp === 'gt')  result = a > b;
      else if (cmp === 'gte') result = a >= b;
      else throw new Error(`compare: unknown cmp '${cmp}'`);
      inst.stack.push(result ? 1 : 0);
      break;
    }
    case 'if': {
      if (inst.stack.length === 0) throw new Error('if: stack underflow');
      const val = inst.stack.pop();
      if (!val) return 'skip';
      break;
    }
    case 'earn': {
      let amount;
      if (op.amount != null) {
        amount = op.amount;
      } else {
        if (inst.stack.length === 0) throw new Error('earn: stack underflow (no amount)');
        amount = inst.stack.pop();
      }
      amount = Math.round(amount * 100) / 100;
      earnMoney(amount, sw.name);
      break;
    }
  }
}

function stopSoftware(swId, instId) {
  const instances = swInstances[swId];
  if (!instances) return;
  if (instId != null) {
    const inst = instances.find(i => i.id === instId);
    if (inst) inst.stopRequested = true;
  } else {
    // Stop all instances
    for (const inst of instances) inst.stopRequested = true;
  }
}

function reinstallSoftware(swId) {
  const sw = installedSoftware[swId];
  if (!sw) return;
  // Stop any running instances first
  stopSoftware(swId);
  log(`Reinstalling ${sw.name}...`, 'warn');
  // Delete old persistent files
  for (const [key, fid] of Object.entries(sw.persistentFileIds)) {
    if (files[fid]) deleteFile(fid);
  }
  sw.persistentFileIds = {};
  // Recreate
  for (const pf of sw.persistentFiles) {
    const id = allocateFile(pf.name, pf.size, { persistent: true, swId: sw.id, silent: true });
    if (id === null) { log(`REINSTALL FAILED: disk full`, 'err'); return; }
    sw.persistentFileIds[pf.key] = id;
  }
  swInstances[swId] = [];
  log(`${sw.name}: reinstalled`, 'action');
  render();
}

// ==========================================
// MONEY
// ==========================================
function earnMoney(amount, source) {
  playerMoney += amount;
  log(`+$${amount.toFixed(2)} earned by ${source}`, 'money');
  showMoneyAnim(amount);
  renderMoney();
}

function spendMoney(amount) {
  if (playerMoney < amount) return false;
  playerMoney -= amount;
  renderMoney();
  return true;
}

function showMoneyAnim(amount) {
  const el = document.createElement('div');
  el.className = 'money-earn-anim';
  el.textContent = `+$${amount.toFixed(2)}`;
  const x = 60 + Math.random() * 100;
  const y = 30 + Math.random() * 30;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1600);
}

function renderMoney() {
  document.getElementById('money-display').textContent = `$ ${playerMoney.toFixed(2)}`;
}

// ==========================================
// SHOP
// ==========================================
function buyShopItem(itemId) {
  const item = SHOP_UPGRADES.find(i => i.id === itemId);
  if (!item || item.bought) return;
  if (RAM_SIZE < item.ramReq) { log(`Need ${item.ramReq} KB RAM to buy ${item.name}`, 'err'); return; }
  if (item.requires) {
    const req = SHOP_UPGRADES.find(i => i.id === item.requires);
    if (!req || !req.bought) { log(`Requires ${req ? req.name : item.requires} first`, 'err'); return; }
  }
  if (!spendMoney(item.price)) { log(`Not enough money for ${item.name}`, 'err'); return; }
  item.bought = true;
  if (item.type === 'hdd') {
    expandDisk(item.value);
  } else if (item.type === 'ram') {
    RAM_SIZE = item.value;
    log(`RAM upgraded to ${RAM_SIZE} KB`, 'action');
  } else if (item.type === 'rhead') {
    addReadHead();
  } else if (item.type === 'whead') {
    addWriteHead();
  }
  renderShop();
  renderStats();
}

function expandDisk(newSize) {
  if (newSize <= DISK_SIZE) return;
  const old = DISK_SIZE;
  DISK_SIZE = newSize;
  disk.length = DISK_SIZE;
  for (let i = old; i < DISK_SIZE; i++) disk[i] = null;
  log(`HDD expanded to ${DISK_SIZE} blocks!`, 'action');
  document.querySelector('.header .subtitle').textContent = `MIRACULOUS DISK DEFRAGMENTER ‚Äî C:\\ DRIVE ‚Äî ${DISK_SIZE} BLOCKS`;
}

function buySoftware(swId) {
  const swDef = SOFTWARE_CATALOG.find(s => s.id === swId);
  if (!swDef) return;
  if (installedSoftware[swId]) { log(`${swDef.name} already installed`, 'warn'); return; }
  if (RAM_SIZE < swDef.ramReq) { log(`Need ${swDef.ramReq} KB RAM to install ${swDef.name}`, 'err'); return; }
  if (!spendMoney(swDef.price)) { log(`Not enough money for ${swDef.name}`, 'err'); return; }
  installSoftware(swDef);
  renderShop();
}

// ==========================================
// DEFRAG ENGINE
// ==========================================
async function startDefrag() {
  if (defragRunning) return;
  defragRunning = true;
  document.getElementById('btn-defrag').disabled = true;
  document.getElementById('btn-stop').disabled = false;
  document.getElementById('defrag-status').textContent = 'ANALYZING...';
  const mode = document.getElementById('defrag-mode').value;
  const speed = parseInt(document.getElementById('defrag-speed').value);
  log(`Starting DEFRAG ‚Äî Mode: ${mode.toUpperCase()}`, 'defrag');
  await sleep(400);
  await runDefrag(mode, speed);
  if (defragRunning) {
    document.getElementById('defrag-status').textContent = 'DEFRAG COMPLETE ‚úì';
    document.getElementById('defrag-progress').style.width = '100%';
    log('Defragmentation complete!', 'defrag');
  }
  defragRunning = false;
  document.getElementById('btn-defrag').disabled = false;
  document.getElementById('btn-stop').disabled = true;
  render();
}

function stopDefrag() {
  defragRunning = false;
  document.getElementById('defrag-status').textContent = 'STOPPED';
  document.getElementById('btn-defrag').disabled = false;
  document.getElementById('btn-stop').disabled = true;
  log('Defrag stopped by user', 'warn');
}

async function runDefrag(mode, speed) {
  let fileOrder = Object.keys(files).map(Number).filter(id => id >= 0);
  if (mode === 'simple' || mode === 'consolidate') {
    fileOrder.sort((a,b) => {
      if (a===0) return -1; if (b===0) return 1;
      return Math.min(...files[a].blocks) - Math.min(...files[b].blocks);
    });
  } else if (mode === 'byname') {
    fileOrder.sort((a,b) => { if (a===0) return -1; if (b===0) return 1; return files[a].name.localeCompare(files[b].name); });
  } else if (mode === 'bydate') {
    fileOrder.sort((a,b) => { if (a===0) return -1; if (b===0) return 1; return files[a].modified - files[b].modified; });
  } else if (mode === 'bysize') {
    fileOrder.sort((a,b) => { if (a===0) return -1; if (b===0) return 1; return files[b].size - files[a].size; });
  }

  let ideal = new Array(DISK_SIZE).fill(null);
  let cursor = 0;
  for (const id of fileOrder) {
    if (!files[id]) continue;
    const size = files[id].blocks.length;
    if (cursor + size > DISK_SIZE) break;
    for (let i = 0; i < size; i++) ideal[cursor + i] = id;
    cursor += size;
  }

  let moves = 0;
  for (let targetPos = 0; targetPos < DISK_SIZE; targetPos++) {
    if (!defragRunning) return;
    const wantedId = ideal[targetPos];
    if (disk[targetPos] === wantedId) continue;

    if (wantedId !== null) {
      let sourcePos = -1;
      for (let i = 0; i < DISK_SIZE; i++) {
        if (disk[i] === wantedId && ideal[i] !== wantedId) { sourcePos = i; break; }
      }
      if (sourcePos === -1) for (let i = 0; i < DISK_SIZE; i++) { if (disk[i] === wantedId) { sourcePos = i; break; } }
      if (sourcePos === -1) continue;

      // Move read head to source, wait for arrival
      await moveReadHead(sourcePos);
      flashBlock(sourcePos, 'defrag-read');

      if (disk[targetPos] !== null) {
        let park = -1;
        for (let i = DISK_SIZE - 1; i >= 0; i--) { if (disk[i] === null) { park = i; break; } }
        if (park !== -1) {
          const displaced = disk[targetPos];
          // Read the displaced block from targetPos, write it to park
          await moveReadHead(targetPos);
          flashBlock(targetPos, 'defrag-read');
          await moveWriteHead(park);
          flashBlock(park, 'defrag-write');
          disk[park] = displaced;
          disk[targetPos] = null;
          const f = files[displaced];
          if (f) { const bi = f.blocks.indexOf(targetPos); if (bi !== -1) f.blocks[bi] = park; }
        }
      }

      disk[targetPos] = wantedId;
      disk[sourcePos] = null;
      const f = files[wantedId];
      if (f) { const bi = f.blocks.indexOf(sourcePos); if (bi !== -1) f.blocks[bi] = targetPos; }

      // Move write head to target, wait for arrival
      await moveWriteHead(targetPos);
      flashBlock(targetPos, 'defrag-write');
      moves++;
      const pct = Math.min(99, Math.round((targetPos / DISK_SIZE) * 100));
      document.getElementById('defrag-progress').style.width = pct + '%';
      document.getElementById('defrag-status').textContent = `DEFRAGGING... ${pct}%  [${moves} MOVES]`;
      if (moves % 3 === 0) { render(); await sleep(speed); }
    }
  }
  render();
}

// Legacy flash (kept for brief visual pop after head arrives)
function flashBlock(pos, cls) {
  const el = document.querySelector(`[data-block="${pos}"]`);
  if (el) { el.classList.add(cls); setTimeout(() => el.classList.remove(cls), 150); }
}

// ==========================================
// BLOCK TOOLTIP
// ==========================================
(function() {
  const tooltip = document.getElementById('block-tooltip');

  document.getElementById('disk-map').addEventListener('mouseover', e => {
    const block = e.target.closest('[data-block]');
    if (!block || !block.dataset.tip) { tooltip.style.display = 'none'; return; }

    tooltip.textContent = block.dataset.tip;
    tooltip.style.display = 'block';

    const map = document.getElementById('disk-map');
    const mapRect = map.getBoundingClientRect();
    const blockRect = block.getBoundingClientRect();
    const tipW = tooltip.offsetWidth;
    const tipH = tooltip.offsetHeight;

    const blockIdx = parseInt(block.dataset.block);
    const col = blockIdx % COLS;
    const row = Math.floor(blockIdx / COLS);

    // Vertical: first row ‚Üí below block, otherwise above
    let top;
    if (row === 0) {
      top = blockRect.bottom + 2;
    } else {
      top = blockRect.top - tipH - 2;
    }

    // Horizontal: interpolate anchor from left edge (col=0) to right edge (col=COLS-1)
    // At col=0: tooltip left edge aligns with block left edge (touches left boundary)
    // At col=COLS-1: tooltip right edge aligns with block right edge (touches right boundary)
    // In between: linearly interpolate the anchor point across the tooltip width
    const t = (COLS <= 1) ? 0 : col / (COLS - 1); // 0..1
    // anchorX is the x position within the tooltip that aligns to the block center
    // at t=0: anchorX=0 (left edge of tooltip at block center)
    // at t=1: anchorX=tipW (right edge of tooltip at block center)
    const blockCenterX = blockRect.left + blockRect.width / 2;
    const anchorX = t * tipW;
    let left = blockCenterX - anchorX;

    // Clamp so tooltip stays within the map horizontally
    left = Math.max(mapRect.left, Math.min(left, mapRect.right - tipW));

    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
  });

  document.getElementById('disk-map').addEventListener('mouseout', e => {
    if (!e.relatedTarget || !e.relatedTarget.closest('[data-block]')) {
      tooltip.style.display = 'none';
    }
  });
})();

// ==========================================
// MANUAL FS OPS
// ==========================================
function opCreate() {
  const name = (document.getElementById('in-filename').value.trim() || 'FILE.DAT').toUpperCase();
  const size = parseInt(document.getElementById('in-size').value) || 8;
  allocateFile(name, size);
  render();
}
function opDelete() {
  if (!selectedFileId || selectedFileId === 0) { log('No file selected', 'warn'); return; }
  const f = files[selectedFileId];
  if (!f) return;
  const name = f.name;
  deleteFile(selectedFileId);
  log(`Deleted ${name}`, 'action');
  render();
}
function opAppend() {
  if (!selectedFileId) { log('No file selected', 'warn'); return; }
  const extra = parseInt(document.getElementById('in-size').value) || 4;
  appendFile(selectedFileId, extra);
  log(`Appended ${extra} blocks to ${files[selectedFileId]?.name}`, 'action');
  render();
}
function opRename() {
  if (!selectedFileId) { log('No file selected', 'warn'); return; }
  const newName = document.getElementById('in-filename').value.trim().toUpperCase();
  files[selectedFileId].name = newName;
  files[selectedFileId].modified = Date.now();
  log(`Renamed to ${newName}`, 'action');
  render();
}
function opModify() {
  if (!selectedFileId) { log('No file selected', 'warn'); return; }
  files[selectedFileId].modified = Date.now();
  log(`Modified ${files[selectedFileId].name}`, 'action');
  render();
}

const adjectives = ['ALPHA','BETA','GAMMA','DATA','TEMP','CACHE','USER','APP','LOG','IMG','VID','DOC','SYS','NET','BIN','LIB'];
const exts = ['DAT','TMP','LOG','BMP','WAV','TXT','DB','CAB'];
function rndName() { return adjectives[Math.floor(Math.random()*adjectives.length)] + Math.floor(Math.random()*999) + '.' + exts[Math.floor(Math.random()*exts.length)]; }
function rndSize(min=3, max=20) { return min + Math.floor(Math.random()*(max-min)); }

function bulkCreate() {
  const count = parseInt(document.getElementById('in-bulk-count').value) || 10;
  for (let i = 0; i < count; i++) allocateFile(rndName(), rndSize(2, 18), {silent:true});
  log(`Bulk created ${count} files`, 'warn');
  render();
}
function bulkDeleteRandom() {
  const count = parseInt(document.getElementById('in-bulk-count').value) || 5;
  const ids = Object.keys(files).map(Number).filter(id => id !== 0 && !files[id].persistent);
  for (let i = 0; i < count && ids.length > 0; i++) {
    const idx = Math.floor(Math.random() * ids.length);
    deleteFile(ids.splice(idx, 1)[0]);
  }
  log(`Bulk deleted up to ${count} files`, 'warn');
  render();
}
function bulkCreateDelete() {
  const count = parseInt(document.getElementById('in-bulk-count').value) || 8;
  const created = [];
  for (let i = 0; i < count; i++) created.push(allocateFile(rndName(), rndSize(2, 12), {silent:true}));
  for (let i = 0; i < created.length; i += 2) { if (created[i]) deleteFile(created[i]); }
  for (let i = 0; i < Math.ceil(count/2); i++) allocateFile(rndName(), rndSize(8, 20), {silent:true});
  log(`Create+Delete cycle done ‚Äî fragmentation increased!`, 'warn');
  render();
}
function bulkAppendAll() {
  const ids = Object.keys(files).map(Number).filter(id => id !== 0);
  for (const id of ids) {
    const extra = rndSize(1, 5);
    appendFile(id, extra);
  }
  log(`Appended to all files ‚Äî heavy fragmentation!`, 'warn');
  render();
}

// ==========================================
// RENDER
// ==========================================
function render() {
  renderDiskMap();
  renderFileList();
  renderStats();
  renderSoftwareList();
  renderShop();
}

function renderDiskMap() {
  const map = document.getElementById('disk-map');
  map.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
  const frag = document.createDocumentFragment();
  for (let i = 0; i < DISK_SIZE; i++) {
    let el = document.querySelector(`[data-block="${i}"]`);
    if (!el) {
      el = document.createElement('div');
      el.className = 'block';
      el.dataset.block = i;
      el.addEventListener('click', () => {
        const bid = disk[parseInt(el.dataset.block)];
        if (bid !== null && bid !== 0 && files[bid]) {
          selectedFileId = (selectedFileId === bid) ? null : bid;
        } else {
          selectedFileId = null;
        }
        renderDiskMap();
        renderFileList();
      });
    }
    const id = disk[i];
    if (id === null) {
      el.className = 'block free';
      el.style.background = '';
      el.style.border = '';
      el.style.filter = '';
      el.style.outline = '';
      el.dataset.tip = `Block ${i}: FREE`;
    } else {
      el.className = 'block used';
      const f = files[id];
      el.style.background = f ? f.color : '#444';
      el.style.border = 'none';
      el.dataset.tip = f ? `Block ${i}: ${f.name}` : `Block ${i}`;
      if (id === selectedFileId) { el.style.filter = 'brightness(1.8)'; el.style.outline = '1px solid white'; }
      else { el.style.filter = ''; el.style.outline = ''; }
    }
    frag.appendChild(el);
  }
  map.innerHTML = '';
  map.appendChild(frag);

  // Reapply head highlights (lost when DOM is rebuilt)
  for (const h of readHeads)  updateHeadVisual(h, h.visBlock);
  for (const h of writeHeads) updateHeadVisual(h, h.visBlock);
}

function renderFileList() {
  const el = document.getElementById('file-list');
  const legend = document.getElementById('legend-files');
  legend.innerHTML = '';
  const ids = Object.keys(files).map(Number).filter(id => id !== 0).sort((a,b) => files[a].name.localeCompare(files[b].name));
  if (ids.length === 0) { el.innerHTML = '<div style="color:var(--green-dim);font-size:11px;padding:4px">No files</div>'; return; }
  el.innerHTML = '';
  for (const id of ids) {
    const f = files[id];
    const frags = countFragments(f.blocks);
    const isFrag = frags > 1;
    const item = document.createElement('div');
    item.className = 'file-item' + (id === selectedFileId ? ' selected' : '');
    item.onclick = () => { selectedFileId = (selectedFileId === id) ? null : id; render(); };
    item.innerHTML = `
      <div class="file-dot" style="background:${f.color}"></div>
      <span class="file-name" title="${f.name}">${f.name}${f.persistent ? ' üîí' : ''}</span>
      <span class="file-size">${f.blocks.length}b</span>
      <span class="file-frag ${isFrag?'bad':'ok'}">${frags}F</span>
    `;
    el.appendChild(item);
    const li = document.createElement('div');
    li.className = 'legend-item';
    li.innerHTML = `<div class="legend-dot" style="background:${f.color}"></div>`;
    legend.appendChild(li);
  }
}

function renderStats() {
  const used = disk.filter(x => x !== null).length;
  const free = DISK_SIZE - used;
  const files_count = Object.keys(files).filter(id => parseInt(id) !== 0).length;
  const frag = getFragmentation();
  const ramUsed = getRamUsed();

  document.getElementById('stat-used').textContent = `${used} BLK`;
  document.getElementById('stat-free').textContent = `${free} BLK`;
  document.getElementById('stat-files').textContent = files_count;
  document.getElementById('stat-capacity').textContent = `${DISK_SIZE} BLK`;
  document.getElementById('stat-ram').textContent = `${RAM_SIZE} KB`;

  const rBusy = readHeads.filter(h => h.inUse).length;
  const wBusy = writeHeads.filter(h => h.inUse).length;
  const rEl = document.getElementById('stat-rheads');
  const wEl = document.getElementById('stat-wheads');
  if (rEl) rEl.textContent = `${readHeads.length - rBusy}/${readHeads.length}`;
  if (wEl) wEl.textContent = `${writeHeads.length - wBusy}/${writeHeads.length}`;

  const fragEl = document.getElementById('stat-frag');
  fragEl.textContent = `${frag}%`;
  fragEl.className = 'stat-value ' + (frag < 20 ? 'good' : frag < 50 ? '' : 'bad');
  if (frag >= 50) fragEl.style.color = 'var(--red)';
  else if (frag >= 20) fragEl.style.color = 'var(--amber)';
  else fragEl.style.color = 'var(--green)';

  document.getElementById('frag-meter').style.width = frag + '%';

  // HW panel
  document.getElementById('hw-ram').textContent = `${RAM_SIZE} KB`;
  document.getElementById('hw-ram-used').textContent = `${ramUsed} KB`;
  document.getElementById('hw-hdd').textContent = `${DISK_SIZE} BLK`;
  const ramPct = RAM_SIZE > 0 ? (ramUsed / RAM_SIZE * 100) : 0;
  document.getElementById('ram-fill').style.width = `${ramPct}%`;
  const hwRh = document.getElementById('hw-rheads');
  const hwWh = document.getElementById('hw-wheads');
  if (hwRh) hwRh.textContent = readHeads.length;
  if (hwWh) hwWh.textContent = writeHeads.length;
}

function renderSoftwareList() {
  const el = document.getElementById('software-list');
  const ids = Object.keys(installedSoftware);
  if (ids.length === 0) {
    el.innerHTML = '<div style="color:var(--green-dim);font-size:11px">No software installed</div>';
    return;
  }

  for (const id of ids) {
    renderSoftwareCard(id, el);
  }
}

function renderSoftwareCard(swId, container) {
  const sw = installedSoftware[swId];
  if (!sw) return;

  const instances = swInstances[swId] || [];
  const anyRunning = instances.some(i => i.running);
  const anyCrashed = instances.some(i => i.crashed);

  let card = document.getElementById(`sw-card-${swId}`);
  if (!card) {
    card = document.createElement('div');
    card.id = `sw-card-${swId}`;
    card.className = 'software-card';
    card.innerHTML = `
      <div class="sw-header">
        <span class="sw-name" data-role="name">${sw.name}</span>
        <span class="sw-badge ${sw.badgeType}" data-role="badge">${sw.badgeType === 'server' ? '‚ü≥ SERVER' : '‚ñ∂ PROG'}</span>
      </div>
      <div class="sw-info" data-role="info"></div>
      <div class="sw-btn-row" data-role="btn-row"></div>
      <div data-role="instances"></div>
    `;
    if (container) container.appendChild(card);
  }

  // Card border state
  card.className = `software-card${anyRunning ? ' running' : ''}${anyCrashed && !anyRunning ? ' crashed' : ''}`;

  // Name style
  const nameEl = card.querySelector('[data-role="name"]');
  nameEl.className = `sw-name ${anyRunning ? 'running-name' : anyCrashed && !anyRunning ? 'crashed-name' : ''}`;

  // Info line
  const infoEl = card.querySelector('[data-role="info"]');
  const runCount = instances.filter(i => i.running).length;
  const infoHtml = `RAM: <span>${sw.ramReq} KB</span> &nbsp; Files: <span>${sw.persistentFiles.length}</span>`
    + (runCount > 0 ? ` &nbsp; <span style="color:var(--cyan)">√ó${runCount} running</span>` : '');
  if (infoEl.innerHTML !== infoHtml) infoEl.innerHTML = infoHtml;

  // RUN / STOP-ALL / REINSTALL buttons
  const btnRow = card.querySelector('[data-role="btn-row"]');
  const canRun = getRamFree() >= sw.ramReq;
  const existingBtn = btnRow.querySelector('button');
  const existingRole = existingBtn ? existingBtn.dataset.btnRole : '';

  let neededRole, neededHtml;
  if (anyRunning && sw.isServer) {
    neededRole = anyCrashed ? 'run-server-crash' : 'run-server';
    neededHtml = `<button class="btn run sw-btn" data-btn-role="${neededRole}" onclick="runSoftware('${swId}')" ${canRun ? '' : 'disabled'}>‚ñ∂ ADD INSTANCE</button>
                  <button class="btn stop-btn sw-btn" onclick="stopSoftware('${swId}')">‚ñ† STOP ALL</button>`
                  + (anyCrashed ? `<button class="btn danger sw-btn" onclick="reinstallSoftware('${swId}')">‚Ü∫ REINSTALL</button>` : '');
  } else if (anyRunning && !sw.isServer) {
    neededRole = anyCrashed ? 'run-multi-crash' : 'run-multi';
    neededHtml = `<button class="btn run sw-btn" data-btn-role="${neededRole}" onclick="runSoftware('${swId}')" ${canRun ? '' : 'disabled'}>‚ñ∂ RUN AGAIN</button>`
                  + (anyCrashed ? `<button class="btn danger sw-btn" onclick="reinstallSoftware('${swId}')">‚Ü∫ REINSTALL</button>` : '');
  } else if (anyCrashed) {
    neededRole = 'crashed';
    neededHtml = `<button class="btn run sw-btn" data-btn-role="crashed" onclick="runSoftware('${swId}')" ${canRun ? '' : 'disabled'}>‚ñ∂ RUN</button>
                  <button class="btn danger sw-btn" onclick="reinstallSoftware('${swId}')">‚Ü∫ REINSTALL</button>`;
  } else {
    neededRole = canRun ? 'run' : 'run-disabled';
    neededHtml = `<button class="btn run sw-btn" data-btn-role="${neededRole}" onclick="runSoftware('${swId}')" ${canRun ? '' : 'disabled'}>‚ñ∂ RUN</button>`;
  }

  if (existingRole !== neededRole) {
    btnRow.innerHTML = neededHtml;
  }

  // Per-instance progress rows (below buttons)
  const instContainer = card.querySelector('[data-role="instances"]');
  const existingRows = {};
  for (const row of instContainer.querySelectorAll('[data-inst-id]')) {
    existingRows[row.dataset.instId] = row;
  }
  const activeIds = new Set();
  for (const inst of instances) {
    activeIds.add(String(inst.id));
    let row = existingRows[inst.id];
    if (!row) {
      row = document.createElement('div');
      row.dataset.instId = inst.id;
      row.style.cssText = 'display:flex;align-items:center;gap:4px;margin:2px 0;';
      instContainer.appendChild(row);
    }
    const pct = Math.round((inst.progress || 0) * 100);
    const crashedHtml = inst.crashed
      ? `<span style="color:var(--red);font-size:10px">‚ö† CRASH</span>`
      : `<div style="flex:1;height:4px;background:var(--bg2);border:1px solid var(--border);overflow:hidden">
           <div style="height:100%;width:${pct}%;background:var(--cyan);transition:width 0.15s"></div>
         </div>
         ${inst.running && sw.isServer
           ? `<button class="btn stop-btn" style="padding:1px 5px;font-size:13px;min-width:0" onclick="stopSoftware('${swId}',${inst.id})">‚ñ†</button>`
           : ''}`;
    row.innerHTML = `<span style="color:var(--green-dim);font-size:10px;min-width:22px">#${inst.id}</span>${crashedHtml}`;
  }
  for (const [idStr, row] of Object.entries(existingRows)) {
    if (!activeIds.has(idStr)) row.remove();
  }
}

function renderShop() {
  const swEl = document.getElementById('shop-list');
  swEl.innerHTML = '';

  // HW upgrades
  for (const item of SHOP_UPGRADES) {
    if (item.bought) continue;
    const canAfford = playerMoney >= item.price;
    const hasRam = RAM_SIZE >= item.ramReq;
    const reqMet = !item.requires || SHOP_UPGRADES.find(i => i.id === item.requires)?.bought;
    const canBuy = canAfford && hasRam && reqMet;
    const div = document.createElement('div');
    div.className = 'shop-item';
    let reqLabel = '';
    if (!reqMet) {
      const req = SHOP_UPGRADES.find(i => i.id === item.requires);
      reqLabel = `<div class="shop-req">Requires: ${req ? req.name : item.requires}</div>`;
    } else if (item.ramReq > 0 && !hasRam) {
      reqLabel = `<div class="shop-req">Requires: ${item.ramReq} KB RAM</div>`;
    }
    let btnLabel = '‚ñ∂ BUY';
    if (!canAfford) btnLabel = `‚ö† NEED $${(item.price - playerMoney).toFixed(2)}`;
    else if (!hasRam) btnLabel = `‚ö† NEED RAM`;
    else if (!reqMet) btnLabel = `‚ö† PREREQ`;
    div.innerHTML = `
      <div class="shop-name">${item.name}</div>
      <div class="shop-desc">${item.desc}</div>
      ${reqLabel}
      <div class="shop-price">$${item.price.toFixed(2)}</div>
      <button class="btn gold-btn" style="margin-top:3px;font-size:11px;" onclick="buyShopItem('${item.id}')" ${canBuy ? '' : 'disabled'}>
        ${btnLabel}
      </button>
    `;
    swEl.appendChild(div);
  }

  // Software purchases
  for (const swDef of SOFTWARE_CATALOG) {
    if (installedSoftware[swDef.id] || swDef.price === 0) continue;
    const canAfford = playerMoney >= swDef.price;
    const hasRam = RAM_SIZE >= swDef.ramReq;
    const div = document.createElement('div');
    div.className = 'shop-item';
    div.innerHTML = `
      <div class="shop-name">${swDef.name}</div>
      <div class="shop-desc">${swDef.desc}</div>
      <div class="shop-req">Requires: ${swDef.ramReq} KB RAM</div>
      <div class="shop-price">$${swDef.price.toFixed(2)}</div>
      <button class="btn gold-btn" style="margin-top:3px;font-size:11px;" onclick="buySoftware('${swDef.id}')" ${canAfford && hasRam ? '' : 'disabled'}>
        ${canAfford && hasRam ? '‚ñ∂ INSTALL' : canAfford ? '‚ö† NEED RAM' : '‚ö† NEED $' + (swDef.price - playerMoney).toFixed(2)}
      </button>
    `;
    swEl.appendChild(div);
  }

  if (swEl.children.length === 0) {
    swEl.innerHTML = '<div style="color:var(--green-dim);font-size:11px">All items purchased!</div>';
  }
}

// ==========================================
// CHKDSK
// ==========================================
function toggleChkdsk() {
  if (chkdskRunning) {
    chkdskStopRequested = true;
  } else {
    runChkdsk();
  }
}

async function runChkdsk() {
  if (chkdskRunning) return;
  chkdskRunning = true;
  chkdskStopRequested = false;
  const btn = document.getElementById('btn-chkdsk');
  btn.textContent = '‚ñ† STOP CHKDSK';
  btn.classList.add('danger');
  log('CHKDSK: Starting disk scan...', 'warn');

  let corrupted = 0;
  let checked = 0;

  for (let i = 0; i < DISK_SIZE; i++) {
    if (chkdskStopRequested) break;

    const id = disk[i];

    // Only care about blocks that have a file id but the file doesn't exist
    if (id !== null && id !== 0 && !files[id]) {
      // Corrupt block ‚Äî read it (so user sees the head travel)
      const rHead = await acquireAndMoveReadHead(i);
      flashBlock(i, 'defrag-read');
      releaseHead(rHead);

      if (chkdskStopRequested) { disk[i] = null; corrupted++; render(); break; }

      // Write-clear it
      const wHead = await acquireAndMoveWriteHead(i);
      flashBlock(i, 'defrag-write');
      disk[i] = null;
      releaseHead(wHead);

      corrupted++;
      render();
    }

    checked++;

    // Update status every 16 blocks to avoid flooding
    if (checked % 16 === 0) {
      log(`CHKDSK: ${checked}/${DISK_SIZE} blocks checked, ${corrupted} corrupt fixed`, 'defrag');
      await sleep(0); // yield so UI can update
    }
  }

  const stopped = chkdskStopRequested && checked < DISK_SIZE;
  if (stopped) {
    log(`CHKDSK: Stopped at block ${checked}. Fixed ${corrupted} corrupt block(s).`, 'warn');
  } else {
    log(`CHKDSK: Scan complete. ${checked} blocks checked, ${corrupted} corrupt block(s) fixed.`, corrupted > 0 ? 'warn' : 'defrag');
  }

  chkdskRunning = false;
  chkdskStopRequested = false;
  btn.textContent = '‚ñ∂ CHKDSK';
  btn.classList.remove('danger');
  render();
}


const logEl = () => document.getElementById('log');
function log(msg, type = '') {
  const line = document.createElement('div');
  line.className = `log-line ${type}`;
  const ts = new Date().toTimeString().slice(0,8);
  line.textContent = `[${ts}] ${msg}`;
  logEl().appendChild(line);
  logEl().scrollTop = logEl().scrollHeight;
  while (logEl().children.length > 100) logEl().removeChild(logEl().firstChild);
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ==========================================
// INIT
// ==========================================
function init() {
  initDisk();
  initHeads();
  log('DEFRAG.EXE v4.2 ‚Äî System initialized', 'action');
  log('C:\\ drive online ‚Äî 512 blocks', '');

  // Auto-install starter software
  const starter = SOFTWARE_CATALOG.find(s => s.id === 'sw_ledger');
  installSoftware(starter);

  // Seed some initial files for visual interest
  allocateFile('PAGEFILE.SYS', 16, {silent:true});
  allocateFile('AUTOEXEC.BAT', 2, {silent:true});
  allocateFile('CONFIG.SYS', 3, {silent:true});
  const id1 = allocateFile('TEMP001.DAT', 12, {silent:true});
  const id2 = allocateFile('CACHE.TMP', 8, {silent:true});
  allocateFile('MSDOS.SYS', 10, {silent:true});
  // Create some gaps
  if (id1) deleteFile(id1);
  allocateFile('IO.SYS', 6, {silent:true});
  if (id2) deleteFile(id2);
  allocateFile('HIMEM.SYS', 9, {silent:true});
  allocateFile('SMARTDRV.EXE', 14, {silent:true});
  const id3 = allocateFile('TEMP002.DAT', 7, {silent:true});
  if (id3) deleteFile(id3);

  log(`Initial fragmentation: ${getFragmentation()}%`, 'warn');
  log('Run LEDGER.EXE to start earning money!', 'money');

  renderMoney();
  render();
}

init();
</script>
</body>
</html>